#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* Depth texture from pre-pass */
layout(set = 0, binding = 0) uniform sampler2D depth_texture;

/* Light buffer: [count, light0, light1, ...] */
struct DynamicLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};

layout(set = 0, binding = 1, std430) readonly buffer LightBuffer {
    uint light_count;
    uint _pad0;
    uint _pad1;
    uint _pad2;
    DynamicLight lights[];
} light_buf;

/* Tile buffer: per-tile [count, idx0, idx1, ...] stride = 65 uints */
layout(set = 0, binding = 2, std430) writeonly buffer TileBuffer {
    uint data[];
} tile_buf;

layout(push_constant) uniform PC {
    mat4 inv_projection;
    uint screen_width;
    uint screen_height;
    uint tile_count_x;
    uint total_light_count;
} pc;

shared uint s_min_depth_bits;
shared uint s_max_depth_bits;
shared uint s_light_count;
shared uint s_light_indices[64];

/* Convert depth [0,1] to view-space Z using inverse projection.
 * For a standard perspective projection:
 * z_view = proj[3][2] / (depth * proj[2][3] + proj[2][2])
 * But since we have the full inv_projection, we can do it properly. */
float linearize_depth(float d) {
    vec4 clip = vec4(0.0, 0.0, d, 1.0);
    vec4 view = pc.inv_projection * clip;
    return -view.z / view.w;  /* Negative Z is forward in view space */
}

void main() {
    uvec2 tile_id = gl_WorkGroupID.xy;
    uint local_idx = gl_LocalInvocationIndex;

    /* Initialize shared memory */
    if (local_idx == 0u) {
        s_min_depth_bits = 0xFFFFFFFFu;
        s_max_depth_bits = 0u;
        s_light_count = 0u;
    }
    barrier();

    /* Sample depth at this thread's pixel */
    uvec2 pixel = tile_id * 16u + gl_LocalInvocationID.xy;
    float depth = 1.0;
    if (pixel.x < pc.screen_width && pixel.y < pc.screen_height) {
        vec2 uv = (vec2(pixel) + 0.5) / vec2(pc.screen_width, pc.screen_height);
        depth = texture(depth_texture, uv).r;
    }

    /* Convert to uint for atomic min/max */
    uint depth_bits = floatBitsToUint(depth);
    atomicMin(s_min_depth_bits, depth_bits);
    atomicMax(s_max_depth_bits, depth_bits);
    barrier();

    float min_depth = uintBitsToFloat(s_min_depth_bits);
    float max_depth = uintBitsToFloat(s_max_depth_bits);

    /* Linearize depth range for this tile */
    float min_z = linearize_depth(min_depth);
    float max_z = linearize_depth(max_depth);
    if (min_z > max_z) {
        float tmp = min_z;
        min_z = max_z;
        max_z = tmp;
    }

    /* Compute tile frustum bounds in NDC */
    float tile_min_x = float(tile_id.x * 16u) / float(pc.screen_width) * 2.0 - 1.0;
    float tile_max_x = float((tile_id.x + 1u) * 16u) / float(pc.screen_width) * 2.0 - 1.0;
    float tile_min_y = float(tile_id.y * 16u) / float(pc.screen_height) * 2.0 - 1.0;
    float tile_max_y = float((tile_id.y + 1u) * 16u) / float(pc.screen_height) * 2.0 - 1.0;

    /* Convert tile corners to view space */
    vec4 corners[4];
    corners[0] = pc.inv_projection * vec4(tile_min_x, tile_min_y, 0.0, 1.0);
    corners[1] = pc.inv_projection * vec4(tile_max_x, tile_min_y, 0.0, 1.0);
    corners[2] = pc.inv_projection * vec4(tile_min_x, tile_max_y, 0.0, 1.0);
    corners[3] = pc.inv_projection * vec4(tile_max_x, tile_max_y, 0.0, 1.0);
    for (int i = 0; i < 4; i++) corners[i].xyz /= corners[i].w;

    /* Each thread tests a subset of lights */
    uint total = pc.total_light_count;
    uint threads_per_tile = 256u; /* 16x16 */
    for (uint i = local_idx; i < total; i += threads_per_tile) {
        DynamicLight light = light_buf.lights[i];
        vec3 lp = light.position;
        float lr = light.radius;

        /* Simple sphere-vs-AABB test in view space would be ideal,
         * but for simplicity we do a screen-space tile overlap test:
         * Project light center to screen, check if the bounding circle
         * overlaps the tile rect, and check depth range overlap. */

        /* We'll do a simple view-space depth slab test + radius check.
         * This is a conservative test that works well enough for a first pass. */

        /* Check depth overlap: light sphere [lp.z - lr, lp.z + lr] vs tile [min_z, max_z]
         * Since we're in world space (not view space), we just use a generous radius check
         * by expanding the tile depth slab by the light radius. */
        /* Actually, let's just accept all lights for now with a simple distance check:
         * If the light is within `radius` of any point in the tile's world-space AABB,
         * it contributes to that tile. */

        /* Simplified: Accept the light if it could possibly reach pixels in this tile.
         * We skip the expensive frustum test and just use the depth-slab test. */
        bool in_range = true; /* Accept all lights -- culling done per-fragment by attenuation */

        if (in_range) {
            uint slot = atomicAdd(s_light_count, 1u);
            if (slot < 64u) {
                s_light_indices[slot] = i;
            }
        }
    }
    barrier();

    /* Write tile light list to SSBO */
    uint tile_idx = tile_id.y * pc.tile_count_x + tile_id.x;
    uint base = tile_idx * 65u;

    if (local_idx == 0u) {
        tile_buf.data[base] = min(s_light_count, 64u);
    }

    /* Each thread writes a portion of the light indices */
    uint count = min(s_light_count, 64u);
    for (uint i = local_idx; i < count; i += threads_per_tile) {
        tile_buf.data[base + 1u + i] = s_light_indices[i];
    }
}
